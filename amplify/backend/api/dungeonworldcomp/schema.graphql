# This "input" configures a global authorization rule to enable public access to
# all models in this schema. Learn more about authorization rules here: https://docs.amplify.aws/cli/graphql/authorization-rules
input AMPLIFY { globalAuthRule: AuthRule = { allow: public } } # FOR TESTING ONLY!

type User @model {
  id: ID!
  name: String!
  email: String!
  # Add other user-related fields as needed
}

type Source @model {
  id: ID!
  name: String!
}

type CharacterClass @model {
  id: ID!
  class: Class! @hasOne
}

type Class @model {
  id: ID!
  name: String!
  description: String!
  source: Source! @hasOne
  damageDiceType: DiceType @hasOne
}

type Spell @model {
  id: ID!
  name: String!
  level: Int!
  type: String!
  ongoing: Boolean
  description: String!
  source: Source! @hasOne
  class: Class! @hasOne
}

type CharacterSpell @model {
  id: ID!
  spell: Spell! @hasOne
  selected: Boolean
  tags: [String]
}

type CharacterGear @model {
  id: ID!
  gear: Gear! @hasOne
  uses: Int
  tags: [String]
}

type Gear @model {
  id: ID!
  description: String!
  weight: Int!
  uses: Int
  tags: [String]
}


type CharacterMove @model {
  id: ID!
  selected: Boolean
  move: Move! @hasOne
}

type Move @model {
  id: ID!
  description: String!
  class: Class! @hasOne
}

type CharacterBond @model {
  id: ID!
  description: String
  bond: Bond! @hasOne
  selected: Boolean
}

type Bond @model {
  id: ID!
  description: String
  class: Class! @hasOne
}

type CharacterAbilityScore @model {
  abilityScore: AbilityScore! @hasOne
  id: ID!
  value: String!
  bonus: Int!
  tags: [String]
}

type AbilityScore @model {
  id: ID!
  name: String!
  shortName: String!
  debility: String!
  debilityPenalty: String!
}

type CharacterRace @model {
  id: ID!
  race: Race! @hasOne
}

type Race @model {
  id: ID!
  name: String
  description: String
  class: Class @hasOne
  source: Source! @hasOne
}

type CharacterAlignment @model {
  id: ID!
  alignment: Alignment! @hasOne
  selected: Boolean
}

type Alignment @model {
  id: ID!
  name: String
  description: String
  class: Class! @hasOne
}

type DiceType @model {
  id: ID!
  name: String
}

type CharacterConditions @model {
  id: ID!
  conditionTypes: [ConditionType] @hasMany
}

type Condition @model {
  id: ID!
  description: String!
  selected: Boolean
}

type ConditionType @model {
  id: ID!
  name: String!
  conditions: [Condition] @hasMany
}

type CharacterLook @model {
  id: ID!
  look: [Look]! @hasMany
}

type Look @model {
  id: ID!
  name: String!
  description: String!
  class: Class! @hasOne
}

type Character @model {
  userId: ID! @index(name: "byUser", queryField: "characterByUser")
  id: ID! @primaryKey
  name: String!
  level: Int
  xp: Int
  armor: Int
  hitPointsMax: Int
  hitPointsCurrent: Int
  coin: Int
  loadMax: Int
  loadCurrent: Int
  isPublic: Boolean
  isCoreTemplate: Boolean
  spells: [CharacterSpell] @hasMany
  gear: [CharacterGear] @hasMany
  sixToTenMoves: [CharacterMove] @hasMany
  twoToTenMoves: [CharacterMove] @hasMany
  startingMoves: [CharacterMove] @hasMany
  bonds: [CharacterBond] @hasMany
  abilityscores: [CharacterAbilityScore] @hasMany
  race: CharacterRace @hasOne
  alignment: CharacterAlignment @hasOne
  tags: [String]
  conditionTypes: [CharacterConditions] @hasMany
  look: CharacterLook @hasOne
  class: CharacterClass @hasOne
  notes: String
}
